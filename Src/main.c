/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "main.h"

void task1_handler(void);//This is task1
void task2_handler(void);//This is task2
void task3_handler(void);//This is task3
void task4_handler(void);//This is task4
void init_systick_timer(uint32_t tick_hz);
void enable_processor_faults(void);
void init_task_stack();
__attribute__ ((naked)) void init_schedular_stack(uint32_t sched_top_of_stack);
__attribute__ (( naked )) void switch_sp_to_psp(void);
uint8_t current_task =1;
uint32_t task_handlers[MAX_TASKS];

uint32_t psp_of_tasks[MAX_TASKS]={T1_STACK_START,T2_STACK_START,T3_STACK_START,T4_STACK_START};
int main(void)
{
	enable_processor_faults();
	init_schedular_stack(SCHED_STACK_START);

	 task_handlers[0]= (uint32_t)task1_handler;
	 task_handlers[1]= (uint32_t)task2_handler;
	 task_handlers[2]= (uint32_t)task3_handler;
	 task_handlers[3]=(uint32_t)task4_handler;

	 init_task_stack();
	 switch_sp_to_psp();
	 init_systick_timer(TICK_HZ);



	task1_handler();
    /* Loop forever */
	for(;;);
}

void task1_handler(){
	while(1){
		printf("This is task1_handler \n");
	}
}
void task2_handler(){
	while(1){
		printf("This is task2_handler \n");
	}
}
void task3_handler(){
	while(1){
		 printf("This  is task3_handler \n");
	}
}
void task4_handler(){
	while(1){
	 printf("This is task4_handler \n");
	}
}
void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

    uint32_t count_value= (SYSTICK_TIM_CLK/tick_hz)-1;
    //Clear the value of SVR
    *pSRVR = 0x00FFFFFFFF;
    //load the value in to SVR
    *pSRVR |= count_value;
    //do some settings
    *pSCSR |= (1<<1);//Enables Systick Exception request
    *pSCSR |= (1<<2);//Indicates the clock source,processor clock source
    //enable the systick
    *pSCSR |= (1<<0); //enable the counter
}
__attribute__((naked)) void init_schedular_stack(uint32_t sched_top_of_stack)
{
	__asm volatile ("MSR MSP,%0"::"r"(sched_top_of_stack):);
	__asm volatile("BX LR");
}

void init_task_stack()
{
	uint32_t *pPSP;
	for(int i = 0; i <MAX_TASKS;i++){
		pPSP = (uint32_t*) psp_of_tasks[i];
		pPSP--;
		*pPSP = DUMMY_XPSR;

		pPSP--;//PC
		*pPSP = (uint32_t)task_handlers[i];

		pPSP--;
		*pPSP=0xFFFFFFFD;
		for(int j = 0; j<13; j++){
		pPSP--;
		*pPSP = 0;
		}
		psp_of_tasks[i] = (uint32_t)pPSP;

	}
}

void get_psp_value(void){
	return psp_of_tasks[current_task];
}
void save_psp_value(uint32_t current_psp_value)
{
	psp_of_tasks[current_task]= current_psp_value;
}
void update_next_task(void)
{
	current_task++;
	current_task %= MAX_TASKS;
}

__attribute__ (( naked )) void switch_sp_to_psp(void){
	//1.Initialize the PSP with TASK1 stack_start
	   //get the value of psp of current task
	__asm volatile("PUSH {LR}");
	__asm volatile("BL get_psp_value");
	__asm volatile ("MSR PSP,R0");
	__asm volatile("POP {LR}");
	//2.Change SP to PSP using CONTROL register
	__asm volatile("MOV R0,#0x02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR");
}
void enable_processor_faults(void)
{
	uint32_t*pSHCSR = (uint32_t*)0XE000ED24;

	*pSHCSR |= (1<<16); //mem_manage
	*pSHCSR |= (1<<17);
	*pSHCSR |= (1<<18);

}

 void SysTick_Handler(void)
{


		/*Save the context of current task */

		//1. Get current running task's PSP value
		__asm volatile("MRS R0,PSP");
		//2. Using that PSP value store SF2( R4 to R11)
		__asm volatile("STMDB R0!,{R4-R11}");

		__asm volatile("PUSH {LR}");

		//3. Save the current value of PSP
	    __asm volatile("BL save_psp_value");



		/*Retrieve the context of next task */

		//1. Decide next task to run
	    __asm volatile("BL update_next_task");

		//2. get its past PSP value
		__asm volatile ("BL get_psp_value");

		//3. Using that PSP value retrieve SF2(R4 to R11)
		__asm volatile ("LDMIA R0!,{R4-R11}");

		//4. update PSP and exit
		__asm volatile("MSR PSP,R0");

		__asm volatile("POP {LR}");

		__asm volatile("BX LR");
}


void HardFault_Handler(){
	printf(" HardFault_Handler \n");
}
void MemManage_Handler(){
	printf(" MemManage_Handler \n");
}
void BusFault_Handler(){
	printf("  BusFault_Handler \n");
}
void UsageFault_Handler(){
	printf("  UsageFault_Handler \n");
}
